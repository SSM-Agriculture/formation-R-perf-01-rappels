---
editor: 
  markdown: 
    wrap: 72
---

# Traitement de données {.backgroundTitre}

## Les tables de données

Les tables de données sont très souvent des objets de type data.frame.
Fonctions utiles :

-   `str()` donne la structure de la table, names() le vecteur des noms
    de colonnes

-   `head()` et `tail()` affichent respectivement, par défaut, les 6
    premières et les 6 dernières lignes de la table

-   `dim()` renvoie un vecteur composé du nombre de lignes et du nombre
    de colonnes de la table

![](img/clipboard-tab1.png)

## Manipulation de données

<br>

-   La partie *Manipulation de données* va fournir les outils
    nécessaires aux traitements classiques à opérer sur une table de
    données.

-   À part pour la lecture et l’écriture de fichiers, les outils
    proposés relèvent des packages **dplyr** et **tidyr** : ils sont
    d’un usage plus simple que les outils R de base et couvrent beaucoup
    des fonctionnalités les plus courantes.

## Outils DPLYR & TIDYR

-   Objectif de dplyr : rassembler dans un seul package les outils de
    manipulation de données les plus importants pour l’analyse des
    données

    ⇒ ensemble de fonctions correspondant à un ensemble d’opérations
      élémentaires

-   Deux principes pour les packages *tidyr* et *dplyr* :

    -   **Usage de fonctions « verbe »** toutes construites sur le même
        principe : le premier paramètre est la table de données sur
        laquelle on travaille.

    -   **Usage de l'opérateur pipe** (issu du package magrittr) Dans
        R-Studio, le raccourci clavier pour cet opérateur est : **Ctrl +
        Shift + M**


::: columns
::: {.column width="50%"}

![](img/clipboard-pipe1.png)
:::

::: {.column width="50%"}

![](img/clipboard-pipe2.png)

:::

::::

## Filtre et sélection dans une table (1/2)

-   **Avec R** de base, on utilise les techniques d'indexation

`ma_table[1,] : toutes les variables pour la première observation`

`ma_table[,4] : toutes les observations de la 4e variable`

`ma_table[,''Profession''] : toutes les observations de la variable Profession`

`ma_table[1,4] : première observation de la 4e variable`

![](img/clipboard-filtre1.png)

## Filtre et sélection dans une table (2/2)

-   Avec le package **dplyr** :

    -   Pour sélectionner des colonnes dans une table, on utilise la
        fonction

        -   select() maTable %\>% select(noms_des_colonnes)

    -   Pour filtrer les lignes dans une table à l’aide de conditions
        logiques, on utilise la fonction filter()

        -   maTable %\>% filter(conditions)

`ma_table %>% filter(Profession == ''Militaire'')`

`ma_table %>% filter(Age < 30) %>% select(Nom_prenom)`

![](img/clipboard-filtre2.png)

## Création ou modification de variables dans une table

-   Avec **R de base**, on utilise l'opérateur d'affectation :

    -   `table$new_var <- variable` → formule générique

    -   `table$new_var <- valeur_constante` → création d'une constante

    -   `table$new_var <- fonction(table$var1)` → création à partir
        d'une formule

    -   `table$new_var <- table$var1 + table$var2` → création à partir
        d'opérations

    -   `table$new_var <- vecteur1 OU table1$new_var <- table2$var1` →
        création à partir de variables externes

    -   `table$new_var <- ifelse(table$varref < x, val1, val2) OU table$new_var <- case_when(table$varref < x ~ val1, TRUE ~ val2)`
        → traitement conditionnel

## Création ou modification de variables dans une table

-   Avec le package **dplyr**, on utilise la fonction `mutate()` qui
    permet de créer plusieurs variables à la fois et permet de
    s'affranchir de l'indexation :

        `table ← table %>% mutate(new_var1 = var1, newvar2 = var2)` →
        formule générique

        `table ← table %>% mutate( new_var1 = constante,` → création
        d'une constante 
        
        `new_var2 = fonction(var1),` → création à partir
        d'une formule

        `new_var3 = var1 + var2,`→ création à partir d'opérations
        arithmétiques\
        
        `new_var4 = vecteur1)` → création à partir de variables externes

    Pour modifier une variable on affecte la nouvelle valeur à une
    variable existante

## Fonctions utiles au traitement des chaînes de caractères

![](img/clipboard-recap-fonctions.png)

## Tri dans une table

-   Pour trier une table selon une ou plusieurs variables, on utilise la
    fonction *arrange()*

`maTable %>% arrange(variables_de_tri)`

<br>

→ possibilité de trier selon plusieurs colonnes : les variables de tri
doivent être séparées par une virgule.

→ on encadre les variables qu’il faut trier de façon décroissante par la
fonction *desc()*.

## Fusion de tables

<br>

-   Pour fusionner deux tables en utilisant une ou plusieurs variables
    de jointure, on utilise les fonctions ***XXX_join()***

![](img/clipboard-join.png)

## Joindre des tables avec une variable de jointure

![](img/clipboard-ex-jointure.png)

## Fusion de tables

-   Il est possible de réaliser une jointure à l'aide de plusieurs
    variables identifiantes : l'argument by s'écrit alors **c(''id1'',
    ''id2'', ...)**

-   Lorsque les variables de jointure ont des noms différents dans les
    deux tables, l'argument by prend comme paramètre un vecteur du type
    **c(''id1_tab1'' = ''id1_tab2'', ''id2_tab1'' = ''id2_tab2'',…)**

-   Si rien n'est précisé, la fusion se fait sur l'ensemble des
    variables portant le même nom dans les deux tables

## Agrégation dans une table

-   Pour résumer les données d'une table en une seule statistique, on
    utilise la fonction `summarise()`

`maTable %>% summarise(fonctions_stat(variable))`

-   Pour agréger les données d'une table par groupe d'une ou plusieurs
    variables catégorielles on utilise la fonction ***group_by()***
    avant la fonction ***summarise()***

`maTable %>% group_by(var_groupe)%>% summarise(fonctions_stat(variable))%>% ungroup()`

→ possibilité de calculer plusieurs statistiques en séparant les
instructions par une virgule

→ on peut utiliser les fonctions statistiques de base telles que max,
min, mean, sd, n…

→ ungroup permet de ne plus tenir compte du regroupement par la suite (avec 
l'argument `drop = FALSE`)

## Transposition ou réorganisation de table

<br>

Pour réorganiser une table, c'est à dire passer des lignes en
colonnes ou inversement, on utilise les fonctions `pivot_wider()` 
et `pivot_longer()` du package tidyr.

## Pivot_wider()

<br>

![](img/clipboard-pivotwider.png){fig-align="center"}
<br>

`maTable %>% pivot_wider(col_de_noms, col_de_valeurs)`
   
- **col_de_noms** = nom de la variable dont les modalités deviendront les intitulés de colonne

- **col_de_valeurs** = nom de la variable à utiliser pour remplir les colonnes

## Pivot_longer()

<br>

![](img/clipboard-pivotlonger.png){fig-align="center"}
<br>

`maTable %>% pivot_longer( variables_apivoter , names_to = "indicateur", values_to = "valeur")`

- **variables_a_pivoter** = nom de l’ensemble des variables à représenter

- **names_to** = nom de la première colonne à créer

- **values_to** = nom de la deuxième colonne à créer

## Exemples sur les pivots

![](img/pivots_exemple.png)

```r
# Passage de tab1 à tab2 avec la fonction pivot_wider()
tab2 ← pivot_wider(tab1, names_from = mesure, values_from = temperature)
# Passage de tab2 à tab1 avec la fonction pivot_longer() 
tab1 ← pivot_longer(tab2, c(min, max, moy), names_to = "mesure", 
  values_to = "temperature")
```
  
## Lecture/ Ecriture de fichiers

+------------------+------------------+------------------+
| Type             | Lecture          | Ecriture         |
+==================+==================+==================+
| Texte            | la fonction r    | la fonction r    |
|                  | e                | e                |
|                  | ader::read_delim | adr::write_delim |
|                  |                  |                  |
|                  |                  |                  |
|                  |                  |                  |
|                  |                  |                  |
|                  |                  |                  |
+------------------+------------------+------------------+
| RDS              | Fonction         | Fonction         |
|                  | read_rds         | readr::write_rds |
+------------------+------------------+------------------+
| XLS              | les fonctions du | les fonctions du |
|                  | package readxl   | package openxlsx |
+------------------+------------------+------------------+
| SAS ou SPSS      | les fonctions    | il vaut mieux    |
|                  | read_sas et      | exporter au      |
|                  | read_spss du     | format texte et  |
|                  | package haven.   | lire le fichier  |
|                  | Attention : il   | dans le logiciel |
|                  | vaut mieux       | d'origine en     |
|                  | exporter au      | tant que fichier |
|                  | format texte     | au format        |
|                  | dans le logiciel | texte !          |
|                  | d'origine pour   |                  |
|                  | le lire en tant  |                  |
|                  | que données      |                  |
|                  | texte dans R.    |                  |
+------------------+------------------+------------------+
| ODS              | la fonction      | la fonction      |
|                  | read_ods du      | write_ods du     |
|                  | package readODS  | package readODS  |
+------------------+------------------+------------------+
| Parquet          | Les packages     | Le package       |
|                  | `arrow` et       | `arrow`]         |
|                  | `duckdb`         |                  |
+------------------+------------------+------------------+

## Base de données avec R

-   R offre la possibilité d'effectuer des requêtes SQL sur des bases de
    données externes.

-   Des informations pour la connexion sont nécessaires :
    library(RPostgres)

`cnx <- dbConnect(Postgres(), dbname = ''sirene'', port = 5432, host = ''00.11.22.33'', user = ''nom_user'', password = ''mdp'')`

-   Il suffit ensuite d'écrire les requêtes normalement à l'aide de la
    fonction dbGetQuery :  
    
`dbGetQuery(cnx, ''SELECT * FROM TABLE'')`
